# Nome: ValoresIniciais_gamma_t_Lambda_it_T23_w09.R
# Objetivo: Simular dados (T=23) com estrutura CUMULATIVA CORRETA baseada em clAI.

# Carregar dados originais
if(file.exists("_dataCaseStudy.r")) {
  source("_dataCaseStudy.r")
} else {
  stop("Erro: Arquivo '_dataCaseStudy.r' não encontrado.")
}

set.seed(987)
cat("--- Iniciando Simulação CUMULATIVA (T=23, w=0.9) ---\n")

# --- PASSO 1: DEFINIR PARÂMETROS E CLUSTERS ---
n_regions <- 75 
n_times   <- 23 
p         <- 3   
K         <- 4   

# Parâmetros Escalares
beta_true  <- c(-1.0, 1.0, 0.5) 
w_true     <- 0.9 
a0_true    <- 1.0
b0_true    <- 1.0

# --- CORREÇÃO CRÍTICA DOS CLUSTERS ---
# O vetor clAI original tem: 4 (Melhor) ... 1 (Pior)
# Nós queremos: Cluster 1 (Melhor) ... Cluster 4 (Pior)
# Fórmula de conversão:
cluster_ids <- 5 - clAI 

# Construir a Matriz h CUMULATIVA correta para o Nimble e para a Geração
# Lógica: Se região é Cluster 3, ela sofre penalidade de gamma1 + gamma2 + gamma3.
# Logo, a linha correspondente em h deve ser [1, 1, 1, 0]
h_cumulativo <- matrix(0, nrow = n_regions, ncol = K)
for(i in 1:n_regions) {
  k <- cluster_ids[i]
  h_cumulativo[i, 1:k] <- 1
}

# --- PASSO 2: DEFINIR GAMMAS ---
gamma_true <- matrix(NA, nrow = K, ncol = n_times)

# Definindo valores (Base + Adicionais)
gamma_true[1, ] <- c(rep(0.05, n_times)) # Penalidade Base (Cluster 1)
gamma_true[2, ] <- c(rep(0.10, n_times)) # Adicional p/ Cluster 2
gamma_true[3, ] <- c(rep(0.10, n_times)) # Adicional p/ Cluster 3
gamma_true[4, ] <- c(rep(0.15, n_times)) # Adicional p/ Cluster 4

# --- PASSO 3: SIMULAR EPSILON CUMULATIVO ---
cat("--- Calculando Epsilon Cumulativo (Baseado em clAI) ---\n")

epsilon_true <- matrix(NA, nrow = n_regions, ncol = n_times)

for(t in 1:n_times) {
  for(i in 1:n_regions) {
    # Soma dos gammas ativados pela matriz h_cumulativo
    # Isso equivale a sum(gamma_true[1:cluster_ids[i], t])
    penalidade <- sum(h_cumulativo[i, ] * gamma_true[, t])
    
    epsilon_true[i, t] <- 1 - penalidade
  }
}

# Simulando Covariáveis e E
x_true <- array(rnorm(n_regions * n_times * p), dim = c(n_regions, n_times, p))
E_raw  <- matrix(runif(n_regions * n_times, 150, 250), nrow = n_regions)
E_true <- E_raw / mean(E_raw) 

# Calcular g_it
g_it_true <- array(NA, dim = c(n_regions, n_times))
for(i in 1:n_regions) {
  for(t in 1:n_times) {
    prod_val <- sum(x_true[i, t, ] * beta_true)
    g_it_true[i, t] <- E_true[i, t] * epsilon_true[i, t] * exp(prod_val)
  }
}

# --- PASSO 4: SIMULAR LAMBDA E Y ---
cat("--- Simulando trajetória lambda_it e Y_it ---\n")

lambda_true <- matrix(NA, nrow = n_regions, ncol = n_times)
Y_ini       <- matrix(NA, nrow = n_regions, ncol = n_times)

at_true  <- matrix(NA, nrow = n_regions, ncol = n_times + 1)
bt_true  <- matrix(NA, nrow = n_regions, ncol = n_times + 1)
att_true <- matrix(NA, nrow = n_regions, ncol = n_times)
btt_true <- matrix(NA, nrow = n_regions, ncol = n_times)

for(i in 1:n_regions) {
  at_true[i, 1] <- a0_true
  bt_true[i, 1] <- b0_true
  
  for(t in 1:n_times) {
    att_true[i, t] <- w_true * at_true[i, t]
    btt_true[i, t] <- w_true * bt_true[i, t]
    
    lambda_true[i, t] <- rgamma(1, shape = att_true[i, t], rate = btt_true[i, t])
    
    mu_it <- lambda_true[i, t] * g_it_true[i, t]
    Y_ini[i, t] <- rpois(1, mu_it)
    
    at_true[i, t+1] <- att_true[i, t] + Y_ini[i, t]
    bt_true[i, t+1] <- btt_true[i, t] + g_it_true[i, t]
  }
}

# --- PASSO 5: PREPARAR OBJETOS PARA O NIMBLE ---

constants_nimble <- list(
  n_regions = n_regions, 
  n_times   = n_times, 
  p         = p, 
  K         = K, 
  h         = h_cumulativo, # Matriz H Corrigida e Cumulativa
  mu_beta   = rep(0, p),
  a_unif    = c(rep(0.0, n_times)), 
  b_unif    = c(rep(0.1, n_times)),  
  delta     = 0.05, 
  a0        = a0_true, 
  b0        = b0_true, 
  w         = w_true
)

data_nimble <- list(
  Y = Y_ini, 
  E = E_true, 
  x = x_true
)

inits_nimble_1 <- list(
  beta   = beta_true,
  gamma  = gamma_true,
  lambda = lambda_true 
)

gamma_init_2 <- matrix(gamma_true*0.9, nrow = K, ncol = n_times)
inits_nimble_2 <- list(
  beta   = rnorm(p, 0, 0.5),
  gamma  = gamma_init_2,
  lambda = matrix(rgamma(n_regions * n_times, 1, 1), nrow = n_regions)
)

inits_list_nimble <- list(inits_nimble_1, inits_nimble_2)

cat("--- Simulação Concluída e Objetos Prontos (Usando clAI para clusters) ---\n")
# Verifica visualmente os Epsilons gerados
print("Resumo dos Epsilons por Cluster (Tempo 1):")
print(tapply(epsilon_true[,1], cluster_ids, mean))